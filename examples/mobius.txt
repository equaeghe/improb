Mobius Inverse and Natural Extension
------------------------------------

This example shows that, in general, the Mobius inverse of a coherent
lower probability cannot be used to calculate its natural extension.

>>> import itertools
>>> import random
>>> from improb.lowprev import LowPrev, BelFunc
>>> random.seed(10)
>>> n = 4
>>> events = [list(event) for event in itertools.product([0, 1], repeat=n)]
>>> gambles = [[random.randint(0,2) for i in range(n)] for j in range(20)]
>>> for i in range(20):
...     # construct a coherent lower probability
...     lpr = LowPrev.make_random(pspace=n, division=10)
...     # construct belief function from mobius inverse
...     bel = BelFunc(mass=lpr.get_mobius_inverse())
...     # check for incoherence
...     for gamble in gambles:
...         if lpr.get_lower(gamble) != bel.get_lower(gamble):
...             for event in events:
...                 if lpr.get_lower(event) != 0:
... 		        print("P_({0})={1}".format(event, float(lpr.get_lower(event))))
...             for event in events:
...                 set_ = frozenset(i for i in range(n) if event[i])
...                 if bel._mass[set_] != 0:
...                     print("m({0})={1}".format(event, float(bel._mass[set_])))
...             print("E_P({0})={1}".format(gamble, float(lpr.get_lower(gamble))))
...             print("E_m({0})={1}".format(gamble, float(bel.get_lower(gamble))))
...             break
...     else:
...         # no incoherence found! try another one
...         continue
...     break
... else:
...     raise RuntimeError("no counterexample found")
P_([0, 0, 1, 0])=0.1
P_([0, 0, 1, 1])=0.3
P_([0, 1, 0, 0])=0.1
P_([0, 1, 0, 1])=0.1
P_([0, 1, 1, 0])=0.2
P_([0, 1, 1, 1])=0.4
P_([1, 0, 0, 0])=0.1
P_([1, 0, 0, 1])=0.2
P_([1, 0, 1, 0])=0.5
P_([1, 0, 1, 1])=0.5
P_([1, 1, 0, 0])=0.2
P_([1, 1, 0, 1])=0.3
P_([1, 1, 1, 0])=0.6
P_([1, 1, 1, 1])=1.0
m([0, 0, 1, 0])=0.1
m([0, 0, 1, 1])=0.2
m([0, 1, 0, 0])=0.1
m([1, 0, 0, 0])=0.1
m([1, 0, 0, 1])=0.1
m([1, 0, 1, 0])=0.3
m([1, 0, 1, 1])=-0.3
m([1, 1, 1, 1])=0.4
E_P([1, 0, 2, 1])=0.8
E_m([1, 0, 2, 1])=0.6

Quick check::

  E_P([1,0,2,1]) >= P_([1,0,1,0])+P_([0,0,1,1])=0.8
  E_m([1,0,2,1]) = 0.1*2+0.2*1+0+0.1*1+0.1*1+0.3*1-0.3*1+0=0.6

However, it seems that the Mobius inverse of a 2-monotone lower
probability *can* be used to calculate its natural extension. The
following simulation seems to confirm this for a space of size 3 (all
coherent lower probabilities on such space are 2-monotone).

>>> import itertools
>>> import random
>>> from improb.lowprev import LowPrev, BelFunc
>>> random.seed(10)
>>> n = 3
>>> events = [list(event) for event in itertools.product([0, 1], repeat=n)]
>>> gambles = [[random.randint(0,5) for i in range(n)] for j in range(20)]
>>> for i in range(20): # increase n if one wishes...
...     # construct a coherent lower probability
...     lpr = LowPrev.make_random(pspace=n, division=10)
...     # construct belief function from mobius inverse
...     bel = BelFunc(mass=lpr.get_mobius_inverse())
...     # check for incoherence
...     for gamble in gambles:
...         if abs(lpr.get_lower(gamble) - bel.get_lower(gamble)) > 1e-6:
...             for event in events:
...                 print("P_({0})={1}".format(event, float(lpr.get_lower(event))))
...             for event in events:
...                 set_ = frozenset(i for i in range(n) if event[i])
...                 print("m({0})={1}".format(event, float(bel._mass[set_])))
...             print("E_P({0})={1}".format(gamble, float(lpr.get_lower(gamble))))
...             print("E_m({0})={1}".format(gamble, float(bel.get_lower(gamble))))
...             break
...     else:
...         # no incoherence found! try another one
...         continue
...     break
... else:
...     raise RuntimeError("no counterexample found") # doctest: +ELLIPSIS
Traceback (most recent call last):
    ...
RuntimeError: no counterexample found
